// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package sqlite

import (
	"context"
	"database/sql"
	"time"
)

const getAllGameHistory = `-- name: GetAllGameHistory :many
SELECT created_at, game_id, move, kind, points, data from game_history
`

func (q *Queries) GetAllGameHistory(ctx context.Context) ([]GameHistory, error) {
	rows, err := q.db.QueryContext(ctx, getAllGameHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameHistory
	for rows.Next() {
		var i GameHistory
		if err := rows.Scan(
			&i.CreatedAt,
			&i.GameID,
			&i.Move,
			&i.Kind,
			&i.Points,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGames = `-- name: GetAllGames :many
SELECT id, created_at, updated_at, description, user_id, rule_id, score, moves, play_state, data from game
`

func (q *Queries) GetAllGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getAllGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.UserID,
			&i.RuleID,
			&i.Score,
			&i.Moves,
			&i.PlayState,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRules = `-- name: GetAllRules :many
SELECT id, slug, created_at, updated_at, mode, description, size_x, size_y, recreate_on_swipe, no_reswipe, no_multiply, no_addition from rule
`

func (q *Queries) GetAllRules(ctx context.Context) ([]Rule, error) {
	rows, err := q.db.QueryContext(ctx, getAllRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rule
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Mode,
			&i.Description,
			&i.SizeX,
			&i.SizeY,
			&i.RecreateOnSwipe,
			&i.NoReswipe,
			&i.NoMultiply,
			&i.NoAddition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSessions = `-- name: GetAllSessions :many
SELECT id, created_at, updated_at, invalid_after, user_id from session
`

func (q *Queries) GetAllSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, getAllSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InvalidAfter,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, created_at, updated_at, username, active_game_id from user
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.ActiveGameID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGame = `-- name: GetGame :one
select id, created_at, updated_at, description, user_id, rule_id, score, moves, play_state, data from game
where id == ?
`

func (q *Queries) GetGame(ctx context.Context, id string) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.UserID,
		&i.RuleID,
		&i.Score,
		&i.Moves,
		&i.PlayState,
		&i.Data,
	)
	return i, err
}

const getRule = `-- name: GetRule :one
select id, slug, created_at, updated_at, mode, description, size_x, size_y, recreate_on_swipe, no_reswipe, no_multiply, no_addition from rule
where id == ? or slug == ?
`

type GetRuleParams struct {
	ID   string
	Slug string
}

func (q *Queries) GetRule(ctx context.Context, arg GetRuleParams) (Rule, error) {
	row := q.db.QueryRowContext(ctx, getRule, arg.ID, arg.Slug)
	var i Rule
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Mode,
		&i.Description,
		&i.SizeX,
		&i.SizeY,
		&i.RecreateOnSwipe,
		&i.NoReswipe,
		&i.NoMultiply,
		&i.NoAddition,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
select id, created_at, updated_at, username, active_game_id from user
where id == ?
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.ActiveGameID,
	)
	return i, err
}

const getUserBySessionID = `-- name: GetUserBySessionID :one
SELECT
       session.id session_id,
       session.created_at session_created_at,
       session.invalid_after session_invalid_after,

       user.id user_id,
       user.created_at user_created_at,
       user.updated_at user_updated_at,
       user.username,

       game.id game_id,
       game.created_at game_created_at,
       game.updated_at game_updated_at,
       game.description game_description,
       game.data game_data,
       game.play_state game_play_state,
       game.score game_score,
       game.moves game_moves,
       game.rule_id rule_id

FROM session session
         INNER JOIN user user on user.id = session.user_id
         INNER JOIN game game on user.active_game_id = game.id
WHERE session.id = ? LIMIT 1
`

type GetUserBySessionIDRow struct {
	ID           string
	CreatedAt    time.Time
	InvalidAfter time.Time
	ID_2         string
	CreatedAt_2  time.Time
	UpdatedAt    sql.NullTime
	Username     string
	ID_3         string
	CreatedAt_3  time.Time
	UpdatedAt_2  sql.NullTime
	Description  sql.NullString
	Data         []byte
	PlayState    int64
	Score        int64
	Moves        int64
	RuleID       string
}

func (q *Queries) GetUserBySessionID(ctx context.Context, id string) (GetUserBySessionIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBySessionID, id)
	var i GetUserBySessionIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.InvalidAfter,
		&i.ID_2,
		&i.CreatedAt_2,
		&i.UpdatedAt,
		&i.Username,
		&i.ID_3,
		&i.CreatedAt_3,
		&i.UpdatedAt_2,
		&i.Description,
		&i.Data,
		&i.PlayState,
		&i.Score,
		&i.Moves,
		&i.RuleID,
	)
	return i, err
}

const insertGame = `-- name: InsertGame :one
INSERT INTO game
(id, created_at, updated_at, description, user_id, rule_id, score, moves, play_state, data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, created_at, updated_at, description, user_id, rule_id, score, moves, play_state, data
`

type InsertGameParams struct {
	ID          string
	CreatedAt   time.Time
	UpdatedAt   sql.NullTime
	Description sql.NullString
	UserID      string
	RuleID      string
	Score       int64
	Moves       int64
	PlayState   int64
	Data        []byte
}

func (q *Queries) InsertGame(ctx context.Context, arg InsertGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, insertGame,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Description,
		arg.UserID,
		arg.RuleID,
		arg.Score,
		arg.Moves,
		arg.PlayState,
		arg.Data,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.UserID,
		&i.RuleID,
		&i.Score,
		&i.Moves,
		&i.PlayState,
		&i.Data,
	)
	return i, err
}

const insertGameHistory = `-- name: InsertGameHistory :one
insert into game_history
(created_at, game_id, move, kind, points, data) 
values 
(?, ?, ?, ?, ?, ?)
RETURNING created_at, game_id, move, kind, points, data
`

type InsertGameHistoryParams struct {
	CreatedAt time.Time
	GameID    string
	Move      int64
	Kind      int64
	Points    int64
	Data      []byte
}

func (q *Queries) InsertGameHistory(ctx context.Context, arg InsertGameHistoryParams) (GameHistory, error) {
	row := q.db.QueryRowContext(ctx, insertGameHistory,
		arg.CreatedAt,
		arg.GameID,
		arg.Move,
		arg.Kind,
		arg.Points,
		arg.Data,
	)
	var i GameHistory
	err := row.Scan(
		&i.CreatedAt,
		&i.GameID,
		&i.Move,
		&i.Kind,
		&i.Points,
		&i.Data,
	)
	return i, err
}

const insertRule = `-- name: InsertRule :one
INSERT INTO rule
(id, slug, created_at, updated_at, description, mode, size_x, size_y, recreate_on_swipe, no_reswipe, no_multiply, no_addition)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, slug, created_at, updated_at, mode, description, size_x, size_y, recreate_on_swipe, no_reswipe, no_multiply, no_addition
`

type InsertRuleParams struct {
	ID              string
	Slug            string
	CreatedAt       time.Time
	UpdatedAt       sql.NullTime
	Description     sql.NullString
	Mode            int64
	SizeX           int64
	SizeY           int64
	RecreateOnSwipe bool
	NoReswipe       bool
	NoMultiply      bool
	NoAddition      bool
}

func (q *Queries) InsertRule(ctx context.Context, arg InsertRuleParams) (Rule, error) {
	row := q.db.QueryRowContext(ctx, insertRule,
		arg.ID,
		arg.Slug,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Description,
		arg.Mode,
		arg.SizeX,
		arg.SizeY,
		arg.RecreateOnSwipe,
		arg.NoReswipe,
		arg.NoMultiply,
		arg.NoAddition,
	)
	var i Rule
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Mode,
		&i.Description,
		&i.SizeX,
		&i.SizeY,
		&i.RecreateOnSwipe,
		&i.NoReswipe,
		&i.NoMultiply,
		&i.NoAddition,
	)
	return i, err
}

const insertSession = `-- name: InsertSession :one
INSERT INTO session
    (id, created_at, updated_at, invalid_after, user_id)
VALUES (?, ?, ?, ?, ?)
RETURNING id, created_at, updated_at, invalid_after, user_id
`

type InsertSessionParams struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    sql.NullTime
	InvalidAfter time.Time
	UserID       string
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, insertSession,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.InvalidAfter,
		arg.UserID,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvalidAfter,
		&i.UserID,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO user
    (id, created_at, updated_at, username, active_game_id)
VALUES (?, ?, ?, ?, ?)
RETURNING id, created_at, updated_at, username, active_game_id
`

type InsertUserParams struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    sql.NullTime
	Username     string
	ActiveGameID string
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Username,
		arg.ActiveGameID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.ActiveGameID,
	)
	return i, err
}

const stats = `-- name: Stats :one
SELECT (SELECT COUNT(*) FROM user) AS users
     , (SELECT COUNT(*) FROM session) AS session
     , (SELECT COUNT(*) FROM game) AS games
     , (SELECT COUNT(*) FROM game where game.play_state = 1) AS games_won
     , (SELECT COUNT(*) FROM game where game.play_state = 2) AS games_lost
     , (SELECT COUNT(*) FROM game where game.play_state = 3) AS games_abandoned
     , (SELECT COUNT(*) FROM game where game.play_state = 4) AS games_current
     , (SELECT max(game.moves) FROM game where game.play_state = 4) AS longest_game
     , (SELECT max(game.score) FROM game where game.play_state = 4) AS highest_score
     , (SELECT CAST(AVG(length(data)*length(data)) - AVG(length(data))*AVG(length(data)) as FLOAT) from game_history where kind = 2) as history_data_variance
     , (SELECT avg(length(data)) from game_history where kind = 2) as combine_data_avg
     , (SELECT max(length(data)) from game_history where kind = 2) as combine_data_max
     , (SELECT min(length(data)) from game_history where kind = 2) as combine_data_min
     , (SELECT CAST(total(length(data)) as INT) from game_history where kind = 2) as combine_data_total
`

type StatsRow struct {
	Users               int64
	Session             int64
	Games               int64
	GamesWon            int64
	GamesLost           int64
	GamesAbandoned      int64
	GamesCurrent        int64
	LongestGame         interface{}
	HighestScore        interface{}
	HistoryDataVariance interface{}
	CombineDataAvg      sql.NullFloat64
	CombineDataMax      interface{}
	CombineDataMin      interface{}
	CombineDataTotal    interface{}
}

func (q *Queries) Stats(ctx context.Context) (StatsRow, error) {
	row := q.db.QueryRowContext(ctx, stats)
	var i StatsRow
	err := row.Scan(
		&i.Users,
		&i.Session,
		&i.Games,
		&i.GamesWon,
		&i.GamesLost,
		&i.GamesAbandoned,
		&i.GamesCurrent,
		&i.LongestGame,
		&i.HighestScore,
		&i.HistoryDataVariance,
		&i.CombineDataAvg,
		&i.CombineDataMax,
		&i.CombineDataMin,
		&i.CombineDataTotal,
	)
	return i, err
}

const updateGame = `-- name: UpdateGame :one
UPDATE game
SET updated_at = ?,
    user_id    = ?,
    rule_id    = ?,
    score      = ?,
    moves      = ?,
    play_state = ?,
    data       = ?
WHERE id = ?
RETURNING id, created_at, updated_at, description, user_id, rule_id, score, moves, play_state, data
`

type UpdateGameParams struct {
	UpdatedAt sql.NullTime
	UserID    string
	RuleID    string
	Score     int64
	Moves     int64
	PlayState int64
	Data      []byte
	ID        string
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, updateGame,
		arg.UpdatedAt,
		arg.UserID,
		arg.RuleID,
		arg.Score,
		arg.Moves,
		arg.PlayState,
		arg.Data,
		arg.ID,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.UserID,
		&i.RuleID,
		&i.Score,
		&i.Moves,
		&i.PlayState,
		&i.Data,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE user
SET updated_at = ?,
    username = ?,
    active_game_id = ?
WHERE id = ?
RETURNING id, created_at, updated_at, username, active_game_id
`

type UpdateUserParams struct {
	UpdatedAt    sql.NullTime
	Username     string
	ActiveGameID string
	ID           string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.UpdatedAt,
		arg.Username,
		arg.ActiveGameID,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.ActiveGameID,
	)
	return i, err
}
