<!DOCTYPE html>
<html lang="en">

<head>
  <title></title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#14141b">
  <link rel="stylesheet" href="https://unpkg.com/pollen-css@4.3.1" />
</head>

<body>


  {{- $g := .data.Assigns.Game -}}
  {{- $h := .data.Assigns.Hints -}}
  {{- $t := .templateGames -}}

  <h1>TallyBoard</h1>
  <p>Early development-build <span id="status"></span> </p>
  <div class="score">
    Score: {{$g.Score}}
  </div>
  <div class="moves">
    Moves: {{$g.Moves}}
  </div>
  {{- if .data.Assigns.Error}}
  <div class="error">
    {{.data.Assigns.Error}}
  </div>
  {{- end -}}
  <div>
    GameSize: <span id="columns" live-hook="cell-update">{{$g.Rules.SizeX}}</span>x<span id="rows"
      live-hook="cell-update">{{$g.Rules.SizeY}}</span>
    ({{$g.ForTemplate.cells | len}})
    <small style="color: var(--color-grey-500); float: right">
      {{$g.Name}}
    </small>
  </div>
  <div class="board" id="board" style="
    grid-template-columns: repeat({{- $g.Rules.SizeX -}}, 1fr);
    grid-template-rows: repeat({{- $g.Rules.SizeY -}}, 1fr);
    ">
    {{- range $i, $cell := $g.ForTemplate.cells -}}
    <div live-hook="cell-update" live-click="select-cell" live-value-i="{{$i}}" data-selected="" class="cell
        {{- if eq $cell.Value 0 }} blank{{ end -}}
        {{- if $g.IsSelected $cell }} selected
          {{- if $g.IsLastSelection $cell }} selectedLast{{ end -}}
        {{- end -}}

  {{- if $h -}}
    {{if $g.IsCellIndexPartOfFirstHint $i $h }} hinted{{- end -}}
  {{- end -}}
  ">
      {{- if gt $cell.Value 0 -}}
      {{$cell.Value}}
      {{- end -}}
    </div>
    {{- end }}
  </div>

  <p>{{$g.Description}}</p>

  <div class="controls">
    <div>
      {{- range $i, $hint := $h -}}
      <div>{{$i}} - {{$hint.Value}} {{$hint.Path}}</div>
      {{- end -}}
    </div>
    <div>
      <button live-click="swipe" live-value-dir="Up">Swipe up</button>
    </div>
    <div>
      <button live-click="swipe" live-value-dir="Left">Swipe left</button>
      <button live-click="swipe" live-value-dir="Right">Swipe Right</button>
    </div>
    <button live-click="swipe" live-value-dir="Down">Swipe Down</button>
  </div>
  <game-buttons>
    <button live-click="restart" live-key="h">Restart</button>
    <button live-click="get-hint" live-key="h">Hint</button>
    <button onclick="document.querySelector('.games').style.display = 'block'">New Game</button>
    <button onclick="document.querySelector('.instructions').style.display = 'block'">Instructions</button>
  </game-buttons>
  <button live-click="new-game" live-value-mode="2">New Random Challenge</button>
  <div class="overlay games" onclick="document.querySelector('.games').style.display = 'none'">
    <button>Cancel</button>
    <button live-click="new-game">New Infinite Game </button>
    <button live-click="new-game" live-value-mode="2">New Random Challenge</button>
    {{- range $i, $tg := $t -}}
    <button live-click="new-game" live-value-mode="1" live-value-template="{{$i}}">
      <div class="gameTitle">
        {{$i}} {{$tg.Name}}
      </div>
      <div class="gameDescription">
        {{$tg.Description}}
      </div>
    </button>
    {{- end -}}
  </div>

  <hr>
  <div class="overlay instructions" onclick="document.querySelector('.instructions').style.display = 'none'">
    <h2>Instructions</h2>

    <ol>
      <li>Select a brick by clicking on it</li>
      <li>Select the next one from one of the last connected brick's direct neighbour to make a chain</li>
      <li>Make a chain of bricks that either are the <strong>sum</strong> or <strong>product</strong> of the target
        brick.</li>
      <li>You can target a brick after making a chain where that brick is the last selected item, and then clicking it
        again</li>
      <li>Swipe in any direction to move the board. Note that is regular game-modes, this also gives you a new random
        brick</li>

    </ol>

  </div>

  <script src="https://hammerjs.github.io/dist/hammer.min.js"></script>
  <script type="module">
    let nRows = {{$g.Rules.SizeY}}
    let nColumns = {{$g.Rules.SizeX}}
    const statusEl = document.querySelector('#status')
    const leftButton = document.querySelector('button[live-value-dir="Left"]')
    const rightButton = document.querySelector('button[live-value-dir="Right"]')
    const upButton = document.querySelector('button[live-value-dir="Up"]')
    const downButton = document.querySelector('button[live-value-dir="Down"]')
    const hintButton = document.querySelector('button[live-click="get-hint"]')
    const restartButton = document.querySelector('button[live-click="restart"]')
    const newRandomButton = document.querySelector('button[live-value-mode="2"]')
    let boardEl = () => document.getElementById('board')
    const swipeAnimationTime = 300
    const state = {
      didAnimate: false,
      isAnimating: false,
    };
    [...boardEl().children].forEach((cEl) => {
      cEl.onclick = (c) => {
        cEl.classList.add('selected')
      }
    })



    const getRows = () => {
      const cells = [...boardEl().children]
      const rows = new Array(nRows).fill(null).map((_, i) => cells.slice(i * nRows, i * nRows + nRows))
      return rows
    }
    const getColumns = () => {
      const cells = [...boardEl().children]

      const columns = new Array(nColumns).fill(null).map(() => ([]))
      for (let i = 0; i < columns.length; i++) {
        for (let j = 0; j < columns.length; j++) {
          columns[i][j] = cells[j * nColumns + i]
        }
      }
      return columns
    }

    const cellIsEmpty = (cell) => !cell || cell.classList.contains('blank')

    var cumulativeOffset = function (el) {
      let element = el
      var top = 0, left = 0;
      do {
        top += element.offsetTop || 0;
        left += element.offsetLeft || 0;
        element = element.offsetParent;
      } while (element);

      return {
        top: top,
        left: left
      };
    };


    const swipe = (positive, vertical) => {

      const rows = vertical ? getColumns() : getRows()
      let didAnimate = false
      for (const [r, row] of rows.entries()) {
        let empties = 0
        for (let i = positive ? row.length - 1 : 0; positive ? i > -1 : i < row.length; i += positive ? -1 : 1) {
          const nextIndex = positive ? i + 1 : i - 1
          const current = row[i]
          if (!current) {
            console.warn('cell was undefined', {r, row, i, rows, boardLength: boardEl().children.length, boardChildren: boardEl().children})
            return false
          }

          if (cellIsEmpty(current)) {
            empties++
            continue
          }
          if (!empties) {
            continue
          }
          const next = row[nextIndex]
          if (!next) {
            continue
          }
          didAnimate = true
          state.didAnimate = true
          state.isAnimating = true
          const targetIndex = positive ? (i + empties) : (i - empties)
          const target = row[targetIndex]

          const pos = cumulativeOffset(current)
          const posNext = cumulativeOffset(target)
          if (vertical) {
            const diffY = (posNext.top - pos.top)
            current.style.transform = `translateY(${diffY}px)`;
          } else {
            const diffX = (posNext.left - pos.left)
            current.style.transform = `translateX(${diffX}px)`;
          }
          current.style.transition = `transform ${swipeAnimationTime}ms var(--easing-standard)`
        }
      }
      return didAnimate
    }

    const swipeUp = () => {
      const didAnimate = swipe(false, true)
      if (!didAnimate) {
        return
      }
      setTimeout(s => {
        upButton.click();
      }, swipeAnimationTime)
    }
    const swipeDown = () => {
      const didAnimate = swipe(true, true)
      if (!didAnimate) {
        return
      }
      setTimeout(s => {
        downButton.click();
      }, swipeAnimationTime)
    }
    const swipeLeft = () => {
      const didAnimate = swipe(false)
      if (!didAnimate) {
        return
      }
      setTimeout(s => {
        leftButton.click();
      }, swipeAnimationTime)
    }
    const swipeRight = () => {
      const didAnimate = swipe(true)
      if (!didAnimate) {
        return
      }
      setTimeout(s => {
        rightButton.click();
      }, swipeAnimationTime)
    }
    window.Hooks = window.Hooks || {}
    const formatTime = (d) => Intl.DateTimeFormat(undefined, {hour: 'numeric', minute: 'numeric', second: 'numeric', }).format(d || new Date())
    window.Hooks["cell-update"] = {

      disconnected: () => {
        statusEl.innerText = `disconnected ${formatTime()}`
        statusEl.style.color = 'var(--color-red)'
      },
      reconnected: () => {
        statusEl.innerText = `reconnected ${formatTime()}`
        statusEl.style.color = 'var(--color-green)'
      },
      updated: () => {
        statusEl.innerText = `updated ${formatTime()}`
        nColumns = Number(document.getElementById('columns').innerText || nColumns)
        nRows = Number(document.getElementById('rows').innerText || nRows)
      },
      beforeUpdate: () => {
        if (state.didAnimate) {
          [...boardEl().children].forEach(c => {c.style.transform = ''; c.style.transition = 'none'})
          state.didAnimate = false
        }
      }
    }


    const getHint = () => hintButton.click()

    document.onkeydown = (e) => {
      switch (e.key) {
        case "ArrowLeft":
        case "a":
          swipeLeft()
          break
        case "ArrowRight":
        case "d":
          swipeRight()
          break
        case "ArrowDown":
        case "s":
          swipeDown()
          break
        case "ArrowUp":
        case "w":
          swipeUp()
          break
        case "h":
          getHint()
          break
        case "c":
          restartButton.click()
          break
        case "n":
          newRandomButton.click()
          break

        default:
          console.log("key", e.key)
          break
      }
    }

    const hammerTime = new Hammer(boardEl(), {
      recognizers: [
        [Hammer.Swipe, {direction: Hammer.DIRECTION_ALL}],
      ]
    })
    hammerTime.on('swipe', (e) => {
      switch (e.direction) {
        case Hammer.DIRECTION_UP:
          swipeUp()
          break
        case Hammer.DIRECTION_DOWN:
          swipeDown()
          break
        case Hammer.DIRECTION_LEFT:
          swipeLeft()
          break
        case Hammer.DIRECTION_RIGHT:
          swipeRight()
          break
      }
    })


  </script>

  <style>
    /* Disables most touch-interactions */
    * {
      touch-action: none;
    }

    /* disable scrolling. I don't really like this at all, but scrolling in a game is not too good. */
    body {
      overflow: hidden;
    }

    .board {
      margin-inline: -4px;
      display: grid;

      width: calc(100% + 8px);

      height: 100%;
      min-height: 60vw;
      max-height: 100vw;
      border: 2px solid var(--color-blue-700);
      border-radius: var(--radius-lg);
    }

    .cell {
      transition: transform 300ms var(--easing-standard);
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 2px solid var(--border-blue-700);
      margin: 2px;
      border-radius: 8px;
      background-color: var(--color-blue-700);
      font-size: 2rem;
      position: relative;
      box-shadow: var(--elevation-4);
    }

    .cell::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url(https://images.freecreatives.com/wp-content/uploads/2016/02/Sky-Blue-Textured-Background-For-Free.jpg);
      background-size: cover;
      opacity: 0.4;
      z-index: 1;
    }

    .cell.blank {
      opacity: 0;
    }

    .cell.hinted:not(.selected) {
      background-color: var(--color-blue-500);
      outline-color: var(--color-purple-700);
      outline-width: 5px;
      outline-style: dotted;
    }

    .cell.selected {
      background-color: var(--color-green);
      color: var(--color-black)
    }

    .cell.selectedLast {
      background-color: var(--color-green-300);
      color: var(--color-black)
    }

    body {
      background-color: var(--color-black);
      color: var(--color-grey-50);
    }

    .controls {
      display: none;
    }

    game-buttons {
      display: flex;
    }

    button {
      background-color: var(--color-blue-700);
      padding: var(--size-2);
      color: var(--color-grey-50);
    }

    .games button,
    game-buttons button {
      flex-grow: 1;
      background-color: var(--color-green-700);
      color: var(--color-gey-50);

      font-size: 1.2rem;
      padding: var(--size-3);
    }

    .error {
      color: var(--color-red);
    }

    .success {
      color: var(--color-green);
    }

    .overlay {
      display: none;
      position: fixed;
      right: 0;
      top: 0;
      left: 0;
      right: 0;
      min-height: 100%;
      ;
      min-width: 100%;
      ;
      padding-block: 10%;
      background-color: #000000;
      z-index: 9999;
    }

    .games button {
      background-color: var(--color-purple-700);
      width: 100%;
    }

    .games button :last-child {
      font-size: 1rem;

    }


    html {
      font-size: 16;
      font-family: var(--font-sans);
    }
  </style>
  <script src="/live.js"></script>
</body>

</html>
