package web

import (
	"embed"
	"encoding/json"
	"fmt"
	"io/fs"
	"net/http"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/carlmjohnson/versioninfo"
	"github.com/ghodss/yaml"
	"github.com/pelletier/go-toml/v2"
)

//go:embed all:static
var webDir embed.FS

func StaticWebHandler() http.Handler {

	fsys := fs.FS(webDir)
	html, _ := fs.Sub(fsys, "static")
	fileserver := http.FileServer(http.FS(html))
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		switch r.URL.Path {
		case "version", "version.json", "version.toml", "version.yaml":
			data := struct {
				Version      string     `json:"version"`
				Revision     string     `json:"revision"`
				Short        string     `json:"short"`
				Dirty        bool       `json:"dirty"`
				LastCommit   *time.Time `json:"last_commit,omitempty"`
				IssueTracker string     `json:"issue_tracker"`
				Repository   string     `json:"repository"`
			}{
				Version:      versioninfo.Version,
				Revision:     versioninfo.Revision,
				Short:        versioninfo.Short(),
				Dirty:        versioninfo.DirtyBuild,
				IssueTracker: "https://github.com/runar-rkmedia/gotally/issues",
				Repository:   "https://github.com/runar-rkmedia/gotally",
			}
			if versioninfo.LastCommit.Year() > 1 {
				data.LastCommit = &versioninfo.LastCommit
			}
			type Encoer interface {
				Encode(j any) error
			}

			switch {
			case strings.HasSuffix(r.URL.Path, "toml"):
				b, err := toml.Marshal(data)
				if err != nil {
					w.Write([]byte(err.Error()))
					return
				}
				w.Header().Set("Content-Type", "application/toml")
				w.Write(b)

			case strings.HasSuffix(r.URL.Path, "yaml"):
				b, err := yaml.Marshal(data)
				if err != nil {
					w.Write([]byte(err.Error()))
					return
				}
				w.Header().Set("Content-Type", "application/yaml")
				w.Write(b)
			default:
				b, err := json.Marshal(data)
				if err != nil {
					w.Write([]byte(err.Error()))
					return
				}
				w.Header().Set("Content-Type", "application/json")
				w.Write(b)
			}
			return
		}

		w.Header().Set("Vary", "Accept-Encoding")
		if hashedFileRegex.MatchString(r.URL.Path) {
			// This should only be for files that can safely be cached for a long
			// time, for instance files that includes a hash for their file-contents
			// like files generated by a web-bundler like vite.
			w.Header().Set("Cache-Control", "max-age=31536000")
		} else {
			ext := path.Ext(r.URL.Path)
			fmt.Println("ext ", ext)
			switch ext {
			case ".otf":
				w.Header().Set("Cache-Control", "max-age=31536000")
			default:
				w.Header().Set("Cache-Control", "max-age=3600")
			}
			// Cache for any other files. In general, I try to keep the cache
			// relatively short while development is ongoing.
		}
		fileserver.ServeHTTP(w, r)
	})
}

var (
	hashedFileRegex = regexp.MustCompile(`\.[0-9a-fA-F]{6,}\.\w{1,8}$`)
)
